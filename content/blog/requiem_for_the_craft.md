---
title: "Requiem for the craft"
date: "2026-02-23"
description: "Software Engineering in 2026"
tags: ["Artificial Intelligence"]
author: "Mike Matovu"
---

In  2021, I wrote my first line of code. And it was beautiful.

Not the code itself, let's be honest, it was probably a broken `<div>` inside a misplaced `<span>`. But the feeling. The sheer electricity of having an `index.html`, a `style.css`, and an `index.js` open side by side, each one a blank canvas waiting for me to mess it up in increasingly creative ways. That was magic.

Back then, we actually wrote code. When something broke — and everything broke, constantly — you'd copy the entire error message, paste it into Google like a desperate prayer, and hope that some blessed soul named **user3234909** on Stack Overflow had faced the exact same issue seven years ago and bothered to answer their own question. We owe that person everything, by the way. Wherever you are, user3234909, I hope you're doing well.

We spent hours on YouTube, not for entertainment, but for survival. Tutorials were our lifeline. Syntax, concepts, real-world projects — you name it, we built it. A restaurant website. A social media clone. A to-do app (obviously). W3Schools was still the reference, and nobody was ashamed to admit it. Those were simpler times.

And here's the thing about those times: people understood every single line of code they wrote. Every CSS rule had a reason. Every function had a story. You could look at someone's portfolio site and feel them in it — the quirky color choices, the slightly-off spacing, the hover effects that were just a little too enthusiastic. There was a human fingerprint on everything, and that fingerprint was beautiful precisely because it was imperfect.

Now, I know what some of you are thinking. The veterans, the folks with 20+ years of experience  are probably looking at me, a guy who started coding five years ago, and thinking: *"You joined the party late and you're already complaining about the music?"* Fair enough. But hear me out anyway.

It's 2026. Here's my morning routine as a software engineer:

I wake up, open my terminal, fire up Claude Code, and tell it to cook.

And guess what? It cooks!. Better than I ever could. Faster, cleaner, more elegant. The kind of code I'd have spent a week refactoring to achieve, it produces in seconds. It doesn't get tired. It doesn't misname variables at 2 AM. It doesn't forget to close a bracket because it was distracted by a podcast.

Sometimes I find myself just… sitting there. Not because I'm thinking through a complex architectural decision or sketching out a clever algorithm. No. I'm sitting there because *my token limit ran out*. That's the bottleneck now. Not my skill. Not my knowledge. My subscription plan.

The personal gratification of pulling off a clean refactor? Gone. Because nine times out of ten, the AI's version is better than what I would have written. And that tenth time? I probably just got lucky.

Here's something that's been eating at me: code reviews.

Why should a reviewer carefully go through a merge request containing 1000 AI-generated files? What exactly are we reviewing at that point? Are we checking the AI's homework? Are we making sure the machine didn't hallucinate a dependency? The whole ritual starts to feel performative.

And test coverage!. A codebase with 100% test coverage sounds impressive until you realize every single test was written by the same AI that wrote the code. The AI is essentially grading its own exam. I'd honestly rather have 60% coverage written by a human who understood what they were testing than a perfect score from a machine that was just pattern-matching its way to green checkmarks.

Now, to be fair this isn't entirely a bad thing. The code works. The tests pass. The product ships. From a pure business standpoint, this is a dream. But from a craftsman's standpoint? Something essential has been lost.

Let's call it what it is: the role of a software engineer is being quietly redefined into something that looks a lot like "AI model supervisor." Your output is no longer determined by how well you can code. It's determined by how well you can instruct. The quality of your constraints. The precision of your prompts. The way you frame a problem for a machine to solve.

And look I get it. There's a skill to that. Prompt engineering is real. Knowing how to decompose a problem so an AI can tackle it effectively is genuinely valuable.

But come on. Come on. It is not the same as personally figuring out how to squeeze a database query from 10 milliseconds down to 1. It's not the same as staring at a profiler output, having that lightbulb moment, and implementing an optimization that makes you feel like you just discovered fire. That kind of problem-solving was addictive. It was the reason most of us got into this field in the first place.

I love(d) Ruby on Rails. Not because it is the fastest framework, or the most scalable, or the most marketable skill on a résumé. I loved it because writing Ruby is a pleasure. The syntax read like poetry. The conventions feel like a conversation with a thoughtful friend. Every `rake db:migrate` was a small ceremony. Every `has_many :through` was a tiny triumph.

Now? I just get to appreciate what the AI has written in Rails. I'm the critic, not the artist. The editor, not the author. And while there's dignity in that role, it's not why I fell in love with this work.

This is the part where I'm supposed to offer a hopeful conclusion. A rallying cry. Some advice about "adapting to the new paradigm" and "leveraging AI as a superpower."


So now, should we keep prompting our way through the workday? Accept our new roles as glorified AI supervisors and learn to find meaning in well-crafted system prompts?

I don't have the answer. But I think the question is worth sitting with. Because here's the cruel irony nobody warns you about: if you decide to keep the joy to keep writing code by hand, to keep learning the hard way, to keep that human fingerprint on everything you build the rest of the world moves on without you. The developer next to you ships ten features while you're lovingly hand-crafting one. The startup across the street builds in a weekend what would take your team a month. Clients don't care about your artisanal code. They care about deadlines. And the market doesn't reward craftsmanship — it rewards speed.

So you're left with an impossible choice. Hold on to the thing that made you fall in love with this work, and watch the industry leave you behind. Or let go of it, keep up with the pace, and quietly mourn something you can't quite name.

Behind all the productivity metrics and the shipped features and the blazing-fast deployment pipelines, there's a quieter truth:

The joy is gone. And I miss it.

---